## Лабораторная работа 5

### Теоретическая справка
**CCЫЛКИ**
* Ссылки, как и указатели, являются сложной для понимания частью языка.
* [Если информации на лекциях было недостаточно или вы что- то успустили](http://cppstudio.com/post/429/)
* Пример работы со сылками (рекомендую ознакомиться) - https://github.com/bmstu-iu8-cpp/cpp-beginner-2017/tree/master/lab5

**ФУНКЦИИ и РАЗДЕЛЕНИЕ НА ФАЙЛЫ**
* Функция- средство языка, которое позволяет в разы (а иногда и в десятки раз) сократить объем вашего кода,
внести в него ясность для других программистов (и проверяющего в частности), реализовать более сложные алгоритмы
и создать универсальное средство решения для типовых задач.
* [Что такое функции и для чего они нужны](http://cppstudio.com/post/396/)
* [Разделение исходного кода на файлы](https://metanit.com/cpp/tutorial/3.8.php)
* [Примеры кода, которые окончательно внесут ясность](https://github.com/bmstu-iu8-cpp/cpp-beginner-2017/tree/master/lab5)
* Чем определение функции отличается от её объявления? Объявление функции сообщает нам лишь о типе её возвращаемого значения,
количсетве аргументов и их типе, а также о том, что в коде мы должны встретить её реализацию. Перед использованием функции мы ВСЕГДА
должны её объявить. Определение функции- это сам код функции, алгоритм. [Подробнее](https://metanit.com/cpp/tutorial/3.1.php)

**ПЕРЕДАЧА АРГУМЕНТОВ ЧЕРЕЗ ССЫЛКИ**
* Сылки используются в С++ повсеместно, поэтому необходимо разобраться в принцие их использования. По ссылкам
передаются переменные в функции, чтобы изменять сам объект, а не его копию. Ссылки позволяют избежать
нежелательного копирования.
* Зачем все- таки передавать аргументы по ссылке - https://metanit.com/cpp/tutorial/3.3.php
* Внимание! Личный опыт подсказывает мне, что большинство ошибок в работе ваших программ будут связаны именно
с необходимостью передавать аргумент по ссылки для его изменения, поэтому в первую очередь проверяйте именно наличие ссылок в
списке аргументов функций там, где это необходимо.

**КОНСТАНТНЫЕ ССЫЛКИ**
* Константные ссылки мы используем для того, чтобы избежать ненужного копирования аргумента, но при этом не изменить
его значение. Дело в том, что функция, как мы уже знаем, работает не с самим аргументом, а с его копией, если передача
аргумента идет по значению. Как следствие, возникает дополнительное копирование, которого мы стремимся избежать. Если аргумент
не должен быть изменен в теле функции, а копировать его нецелесообразно, используем константные ссылки.
* Читаем на эту тему подробнее [тут](http://alenacpp.blogspot.com/2005/09/const-1.html)

### Инструкция
- Каждое задание должно быть выполненно в отдельном `.cpp` файле.
- Прототипы функции должны быть вынесены в соответствующие `.hpp` файлы.
- Все реализованные функции необходимо вызвать в фунции `main` в файле [lab05](lab05.cpp)
- Все `.cpp` файлы добавить в `CMakeLists.txt`
Внимание! Все `.cpp` файлы добавляются в `add_executable()` (после файла `test.cpp`).Если этого не сделать,
компилятор не сможет самостоятельно найти файлы с реализацией ваших функций. Файл, содержащий
фунцию `main`, подключать не нужно, иначе будет выполняться она, а не тесты. Подробнее о составлении `CMakeLists.txt`
(для интересующихся) можно почитать [тут](https://habr.com/post/155467/).

### Задание
1. Необходимо реализовать функцию, которая определяет арифметическое средее в массиве.
Прототип функции:
```cpp
float mean(const std::vector<float>&);
```

2. Необходимо реализовать функцию, которая определяет максимум и минимум в массиве. 
Прототип функции:
```cpp
// .first is min
// .second is max
std::pair<float, float> minMax(const std::vector<float>&);
```
Если массив пуст, функция должна вернуть `std::numeric_limits`.
Об этом можно почитать [тут](https://en.cppreference.com/w/cpp/types/numeric_limits).

3. Необходимо реализовать функцию `argmax`, которая определяет индекс максимума в массиве. 
Прототип функции необходимо выбрать самостоятельно.
Нумерация элементов массива начинается с нуля.
Если массив пуст, функция должна вернуть `-1`.

4. Необходимо реализовать функцию, которая сортирует входной массив.
Стандартными функциями для сортировки массива пользоваться нельзя!
Прототип функции:
```cpp
void sort(std::vector<float>&);
```

5. Необходимо реализовать функцию `remove_first_negative_element`, которая удаляет первый отрицательный элемент массива.
Прототип функции:
```cpp
bool remove_first_negative_element(const std::vector<int>& vec, int& removed_element);
```
Функция возвращает `true` если удалось удалить элемент, а `false` если не удалось.
Значение удаленного элемента помещать в `removed_element`, если удаление не произошло то инициализировать `removed_element` нулем.

6. Необходимо реализовать функцию, которая заменяет в строке все вхождения подстроки на новую строку.
Можно пользоваться функцией `std::string::find`, о которой можно почитать [тут](https://ru.cppreference.com/w/cpp/string/basic_string/find).
```cpp
std::string replace(const std::string& str, const std::string& old, const std::string& new);
```
Пример:
```cpp
std::string newString = replace("Can you can a can as a canner can can a can?", "can", "cAN");
std::cout << newString; // "Can you cAN a cAN as a cANner cAN cAN a cAN?"
```

7. Необходимо реализовать функцию `split`, которая делит строку по заданному символу.
```cpp
std::vector<std::string> split(const std::string&, char sep);
```
Пример:
```cpp
std::vector<std::string> arr = split("Can you can a can as a canner can can a can?", ' ');
// arr == {"Can", "you", "can", "a", "can", "as", "a", "canner", "can", "can", "a", "can?"};
```
Если строка состоит только из символов которые указаны вторым аргументом, функция должна вернуть пустой вектор.

8. Необходимо реализовать функцию, которая соединяет массив строк в одну строку.
```cpp
std::string join(const std::vector<std::string>&, const std::string& sep);
```
Пример:
```cpp
std::vector<std::string> arr = {"Can", "you", "can", "a", "can", "as", "a", "canner", "can", "can", "a", "can?"};
std::string str = join(arr, " ");
// str == "Can you can a can as a canner can can a can?"
```
